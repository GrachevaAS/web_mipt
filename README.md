# TicketLock против TestAndSetLock
При освобождении какого-нибудь ядра на нём сразу начинает выполняться другой поток (какой - выбирает планировщик). При этом в TestAndSetLock выбранный поток сразу входит в критическую секцию и принимается за дело. В TicketLock же планировщик может выбрать не тот поток, который имеет следующий "номерок". Тогда он будет выполняться на этом ядре, но на самом деле - крутиться в цикле while, не совершая полезной работы.
Тогда если потоков меньше чем вычислительных ядер (или столько же), это никак не повлияет на производительность, т.к. они все будут выполняться параллельно. А если потоков **строго больше чем вычислительных ядер**, время ожидания своей очереди увеличивается, и происходит деградация производительности.

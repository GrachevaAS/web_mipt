  # Tricky Lock
  ```
  void Lock() {
    while (thread_count_.fetch_add(1) > 0) {
      thread_count_.fetch_sub(1);
    }
  }
  
  void Unlock() {
    thread_count_.fetch_sub(1);
  }
  ```  
  Можно предъявить исполнение, в котором потоки бесконечно долго не могут захватить свободный лок (пример 2х потоков):  
  
  - 1й поток заходит в Lock(). thread_count == 0, поэтому 1й поток выходит из while
  - 2й поток заходит в Lock(). thread_count == 1, 2й поток заходит в тело цикла (при этом thread_count == 2)
  - 1й поток вызывает Unlock(), thread_count == 1
  - 1й поток снова вызывает Lock(). thread_count == 1, поэтому 1й поток заходит в тело цикла (при этом thread_count == 2)
  - 2й поток вычитает 1, на новой итерации прибавляет 1 и снова заходит в тело цикла (thread_count вернулся к 2)
  - аналогично 1й поток, и далее по очереди  
  
  В этом примере потоки будут бесконечно чередоваться (т.е. ни один не заморожен), но глобального прогресса не будет, так как ни один поток не войдёт в критическую секцию.
  
